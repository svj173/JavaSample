Триада MVC в действии


Автор: Андрей Озеров (к.ф.м.н.)


Дата публикации: 01.12.2003 05:36

J2EE


Пожалуй, каждый программист, проектирующий комплексную графическую систему, сталкивался с проблемами компоновки, дизайна и реализации бизнес-логики в рамках имеющихся ресурсов. И не важно, какие технологии задействованы в этой реализации – бизнес-приложение с использованием MFC классов или графическая система на основе Swing-библиотек. Особенно актуальна эта проблема при разработке и поддержки web-services, основанных на JSP и сервлетах, а также прогрессирующей в настоящее время .NET технологии ASP .NET.

В связи с чем, используя стандартные подходы и методики реализации бизнес-приложений, когда логика встраивается непосредственно в код программы, программистам становится сложно поддерживать внутренний интерфейс таких сложных систем. Тем более, если спроектированная система требует постоянных обновлений и изменений. Порой, чтобы изменить незначительную деталь в каком-то компоненте, программисту требуется переписать код других компонентов, не задействованных в процессе. С такими примерно проблемами столкнулись разработчики модулей для поддержки графического интерфейса в языке Smalltalk несколько лет тому назад. Тогда, программистам удалось найти удачное решение в виде паттерна проектирования MVC[1], который и стал центральной основой для всего графического интерфейса приложений, построенных с использованием языка Smalltalk. Детальное объяснение и описание модели MVC можно найти в книге "Inside Smalltalk"[2]. Цель же данной статьи – дать рекомендации по улучшению кода ваших программ и научить - правильно пользоваться паттерном Модель-Вид-Контроллер.
Что такое MVC?
Давайте рассмотрим паттерн MVC в рамках классической структуры представления паттернов. Итак,
Назначение
Архитектурный паттерн Модель-Вид-Контроллер (MVC) делит программу на три части. В триаде в обязанности компонента Модель (Model) входит хранение данных и обеспечение интерфейса к ним. Вид (View) ответственен за представление этих данных пользователю. Контроллер (Controller) управляет компонентами, получая сигналы в виде реакции на действия пользователя, и уведомляя об изменениях модель компонента. Такая внутренняя структура в целом разбивает систему на самостоятельные части и распределяет ответственность всего приложения на различные компоненты. Архитектура такого взаимодействия представлена на рисунке 1.


Рис.1 Архитектура MVC-модели

Мотивация
MVC делит рассматриваемую часть системы на три самостоятельных части: ввод данных, компонент обработки данных и вывод информации. Модель, как уже было отмечено выше, инкапсулирует ядро данных и основной функционал по их обработке. Также компонент Модель не зависит от процесса ввода или вывода данных. Компонент вывода Вид может представлять собой несколько взаимосвязанных областей, например, различные таблицы и поля форм, в которых отображается информация. В функции Контроллера входит мониторинг за событиями, возникающими в результате действий пользователя (изменение положения курсора мыши, нажатие кнопки или ввод данных в текстовое поле).

Регистрируемые события транслируются в различные запросы, направляемые компонентам Модели или объектам, ответственным за отображение данных. Разделение модели от представления данных позволяет независимо использовать различные компоненты для отображения информации. Таким образом, если пользователь через Контроллер внесет изменения в Модель данных, то информация, представленная одним или несколькими визуальными компонентами, будет автоматически откорректирована в соответствии с произошедшими изменениями.


Рис.2 Диаграмма взаимодействия MVC-модели



Реализация
Паттерн MVC впервые применился при проектировании языка программирования Smalltalk в качестве модели для пользовательского интерфейса (LaLonde, W.R. and J.R. Pugh, Inside Smalltalk, Volume II, Prentice-Hall, 1991.) (Krasner, G.E. and S.T. Pope, A cookbook for using the Model-View-Controller user interface paradigm in Smalltalk-80, Journal of Object-Oriented Programming, 1(3), pp. 26-49, August/September 1988, SIGS Publications, New York, NY, USA, 1988.) Также в область применения паттерна входит реализация каркаса Документ-Вид (Document-View) в рамках библиотеки MFC[3] для языка Visual C++ (Kruglinski, D., Inside Visual C++, Microsoft Press, 1995.). В современных технологиях паттерн MVC представлен схемой JSP Model 1/2 для динамической обработки Web-содержания на основе Java Server Pages (JSP)[4].
Результаты
В результате использования парадигмы MVC программист получает в свое распоряжение мощную структуру объектов-компонентов, функции которых строго разграничены, что гарантирует надежность и расширяемость разрабатываемой системы.
Использование
Можно привести множество примеров, демонстрирующих всю мощь использования триады Модель-Вид-Контроллер, однако, наилучшим образом эта схема реализована в языке программирования Java, где она поддерживается на уровне стандартных классов-библиотек. Далее будут рассмотрены два аспекта применимости MVC.
MVC и Swing
Разработчики графических библиотек-классов для Java не стали открывать Америку. При проектировании Swing-интерфейса для поддержки графики они также использовали технику программирования, основанную на паттернах. При более детальном знакомстве со Swing-классами можно заметить, что многие из них основаны на таких паттернах, как Adapter, Bridge, Decorator, Command, Observer, Composite и т.д.[5] Однако, пожалуй, самым главным паттерном в такой сложной системе является триада MVC. Возьмем, к примеру, компонент - кнопку, представленную классом JButton. В данном случае, модель из триады MVC представлена интерфейсом ButtonModel, которая инкапсулирует внутреннее состояние кнопки и определяет ее поведение. В целом модель кнопки отвечает за следующие процессы:

    * - наблюдение и управление внутренним состоянием объекта;
    * - регистрация и удаление объектов-событий (Event Listeners);
    * - инициализация событий.

За представление вида отвечает интерфейс ButtonUI. Классы, которые наследуют этот интерфейс, ответственны за графическое представление компонента кнопки и управление событиями, инициализируемыми действиями пользователей. Методы интерфейса ButtonUI можно также разбить на категории:

    * - отрисовка компонента (метод Paint);
    * - установка и возврат информации о размере компонента;
    * - управление событиями AWT.

Рассмотренный выше пример использования парадигмы MVC затрагивает лишь незначительную часть тех возможностей, которые дает программистам библиотека Swing. На самом деле, практически каждый компонент из этой библиотеки имеет свою модель, которая отвечает за внутреннее представление компонента, а также интерфейсы представления графической информации, при помощи которых можно полностью перестроить внешний вид компонентов под ваши нужды.
Swing-приложение с использованием модели MVC.
Для более детального ознакомления с практикой программирования и дизайна GUI-приложений на основе MVC, можно привести небольшой пример, который позволит понять суть взаимодействия отдельных элементов из схемы модель-вид-контроллер. Давайте напишем Java - приложение на базе компонента JFrame с набором панелей JPanel, каждая из которых содержит отдельные GUI-объекты (JList, JComboBox, JTextField и JButton).


Рис.3 Пример использование MVC в Swing-приложении


Логика такого приложения будет проста: при нажатии кнопки Add, информация, записанная в текстовом поле элемента JTextField, должна быть добавлена и в элемент JList, и в список поля JComboBox.

По началу, самым простым решением, которое придет в голову, может показаться - определение всей логики в методе класса, наследуемого интерфейс определенного слушателя (listener). Например, для кнопки Add код будет выглядеть следующим образом:
Листинг 1

// ......

m_btnAdd.addActionListener(new ActionListener() {

  public void actionPerformed(ActionEvent e) {

    // Some actions

    //             .................

  }

});



Такой подход будет действительно простым и быстрореализуемым, однако, впоследствии, когда вам нужно будет изменить внешний вид приложения или внести что-то новое в бизнес-логику системы, придется переписать достаточное количество кода. В связи с этим, давайте попробуем спроектировать приложение на базе каркаса MVC-парадигмы.

В первую очередь необходимо определить объекты, которые будут выступать в качестве представителей элементов MVC-модели. В данном случае, мы создадим класс DataModel, в задачи которого будут входить хранение данных и их передача в компоненты через специальные объекты-слушатели (listeners). Также, мы создадим класс, наследующий объект JList, и класс, расширяющий JComboBox, которые будут ответственны за графическое представление данных. Для взаимодействия между всеми элементами системы необходимо создать специальные классы-адаптеры, через которые будет происходить оповещение и изменение модели каждого объекта. Графическое представление и отрисовка всех Swing-объектов будет происходить на базе класса StartUp, который расширяет класс JFrame. Вот как выглядит схема взаимодействия всех элементов приложения:


Рис.4 Архитектура тестового приложения

Таким образом, каждый элемент схемы будет выполнять только ту работу, которую он должен выполнять. А это означает, что при добавлении новых объектов в систему нам больше не нужно будет заботиться о постоянном изменении кода. Достаточно будет написать дополнительный класс, ответственный за внешний вид компонента, определить для него подходящую бизнес-модель и соединить все части при помощи адаптера.


Хочется обратить внимание на пример кода класса DataModel из Листинга 4. Здесь в качестве хранилища объектов-слушателей выступает экземпляр класса EventListenerList. Для каждого компонента на форме, который заинтересован в обновление своих данных, создается класс, наследующий интерфейс ChangeListener (см. Листинг 5 для класса StartUp.java). Далее экземпляр этого класса добавляется в хранилище EventListenerList при помощи метода addChangeListener (ChangeListener l). При нажатии пользователем кнопки Add, происходит добавление данных в модель - экземпляр класса DataModel, при помощи метода addData(String p_str), а затем вызов метода fireChange(), внутри которого в цикле происходит опрос всех участников-слушателей с последующим обновлением модели через них каждого компонента.
Листинг 4 DataModel.java

Пример кода адаптеров-слушателей для каждого компонента приведен в Листинге 5 в виде статических внутренних классов AdapterEditFieldToModel, AdapterModelToList, AdapterModelToComboBox.
Листинг 5 StartUp.java


В заключение, необходимо отметить, что эффективное использование паттернов проектирования позволяет не только повысить качество программного обеспечения, но и сократить время на их реализацию и дальнейшую поддержку. Берегите свое время и время ваших работодателей, господа!

Ссылки
[1] Паттерны проектирования - набор техник и методик, направленный на решение различных проблем, связанных с созданием ПО
[2] "Inside Smalltalk" Wilf R. LaLonde / John R. Pugh, Inside Smalltalk, Volume II, 1991, Prentice Hall
[3] MFC Microsoft Foundation Classes - Библиотека базовых классов Microsoft. Библиотека классов языка C++, предназначенная для разработки приложений для Windows.
[4] JSP (Java Server Pages) - Серверные страницы Java. Технология создания динамических Web-страниц с использованием Java.
[5] Использование и применение паттернов проектирования описано в книге "Design Patterns: Elements of Reusable Object-Oriented Software" Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides; Addison-Wesley, 1995

